from __future__ import annotations
from abc import abstractmethod, ABC
from collections import abc
import re
import datetime
import calendar
import email.utils as eut
from time import mktime
from urllib.parse import urlsplit

import jsonpickle
import dateutil.parser
from apimatic_core_interfaces.formats.datetime_format import DateTimeFormat
from apimatic_core_interfaces.types.union_type import UnionType
from jsonpointer import JsonPointerException, resolve_pointer
from typing import Optional, Any, Dict, Type, Callable, List, Union, Tuple, Set

from apimatic_core.types.file_wrapper import FileWrapper
from apimatic_core.types.array_serialization_format import SerializationFormats
from urllib.parse import quote
from pydantic import BaseModel, validate_call
from pydantic.fields import FieldInfo


class ApiHelper(object):
    """A Helper Class for various functions associated with API Calls.

    This class contains static methods for operations that need to be
    performed during API requests. All of the methods inside this class are
    static methods, there is no need to ever initialise an instance of this
    class.

    """

    class CustomDate(ABC):

        """ A base class for wrapper classes of datetime.

        This class contains methods which help in
        appropriate serialization of datetime objects.

        """

        def __init__(self, dtime, value=None):
            self.datetime = dtime
            if not value:
                self.value = self.from_datetime(dtime)
            else:
                self.value = value

        def __repr__(self):
            return str(self.value)

        def __getstate__(self):
            return self.value

        def __setstate__(self, state):  # pragma: no cover
            pass

        @classmethod
        @abstractmethod
        def from_datetime(cls, date_time: datetime.datetime):
            pass

        @classmethod
        @abstractmethod
        def from_value(cls, value: str):
            pass

    class HttpDateTime(CustomDate):

        """ A wrapper class for datetime to support HTTP date format."""

        @classmethod
        def from_datetime(cls, date_time):
            return eut.formatdate(timeval=mktime(date_time.timetuple()), localtime=False, usegmt=True)

        @classmethod
        def from_value(cls, value):
            dtime = datetime.datetime.fromtimestamp(eut.mktime_tz(eut.parsedate_tz(value)))
            return cls(dtime, value)

    class UnixDateTime(CustomDate):

        """ A wrapper class for datetime to support Unix date format."""

        @classmethod
        def from_datetime(cls, date_time):
            return calendar.timegm(date_time.utctimetuple())

        @classmethod
        def from_value(cls, value):
            dtime = datetime.datetime.utcfromtimestamp(float(value))
            return cls(dtime, int(value))

    class RFC3339DateTime(CustomDate):

        """ A wrapper class for datetime to support Rfc 3339 format."""

        @classmethod
        def from_datetime(cls, date_time):
            return date_time.isoformat()

        @classmethod
        def from_value(cls, value):
            dtime = dateutil.parser.parse(value)
            return cls(dtime, value)

    SKIP = '#$%^S0K1I2P3))*'

    @staticmethod
    @validate_call
    def json_serialize_wrapped_params(obj: Optional[Dict[str, Any]]) -> Optional[str]:
        """JSON Serialization of a given wrapped object.

        Args:
            obj (object): The object to serialize.

        Returns:
            str: The JSON serialized string of the object.

        """
        if obj is None:
            return None
        val = dict()
        for k, v in obj.items():
            val[k] = ApiHelper.json_serialize(v, should_encode=False)

        return jsonpickle.encode(val, False)

    @staticmethod
    @validate_call
    def json_serialize(obj: Any, should_encode: bool=True) -> Optional[str]:
        """JSON Serialization of a given object.

        Args:
            obj (object): The object to serialize.
            should_encode: whether to encode at end or not

        Returns:
            str: The JSON serialized string of the object.

        """

        if obj is None:
            return None

        if isinstance(obj, str):
            return obj

        # Resolve any Names if it's one of our objects that needs to have this called on
        if isinstance(obj, list):
            value_list: List[Optional[str]] = list()
            for item in obj:
                if isinstance(item, dict) or isinstance(item, list):
                    value_list.append(ApiHelper.json_serialize(item, should_encode=False))
                elif ApiHelper.is_custom_type(item):
                    value_list.append(ApiHelper.json_serialize(item, should_encode=False))
                else:
                    value_list.append(item)
            obj = value_list
        elif isinstance(obj, dict):
            value_dict: Dict[str, Optional[str]] = dict()
            for key, item in obj.items():
                if isinstance(item, list) or isinstance(item, dict):
                    value_dict[key] = ApiHelper.json_serialize(item, should_encode=False)
                elif ApiHelper.is_custom_type(item):
                    value_dict[key] = ApiHelper.json_serialize(item, should_encode=False)
                else:
                    value_dict[key] = item
            obj = value_dict
        elif ApiHelper.is_custom_type(obj):
            return obj.model_dump_json() if should_encode else obj.model_dump()
        if not should_encode:
            return obj
        return jsonpickle.encode(obj, False)

    @staticmethod
    @validate_call
    def is_custom_type(obj_or_class: Any) -> bool:
        return (isinstance(obj_or_class, type) and
                issubclass(obj_or_class, BaseModel) or
                isinstance(obj_or_class, BaseModel))

    @staticmethod
    @validate_call
    def json_deserialize(
            json: Optional[str], unboxing_function: Optional[Callable[[Any], Any]]=None, as_dict: bool=False
    ) -> Any:
        """JSON Deserialization of a given string.

        Args:
            json (str): The JSON serialized string to deserialize.
            unboxing_function (callable): The deserialization funtion to be used.
            as_dict (bool): The flag to determine to deserialize json as dictionary type

        Returns:
            dict: A dictionary representing the data contained in the
                JSON serialized string.

        """
        if json is None or json.strip() == '':
            return None

        try:
            decoded = jsonpickle.decode(json)
        except ValueError:
            return json

        if unboxing_function is None:
            return decoded

        if as_dict:
            return {k: unboxing_function(v) for k, v in decoded.items()}
        elif isinstance(decoded, list):
            return [unboxing_function(element) for element in decoded]

        return unboxing_function(decoded)

    @staticmethod
    @validate_call
    def dynamic_deserialize(dynamic_response: Optional[str]) -> Any:
        """JSON Deserialization of a given string.

        Args:
            dynamic_response (str): The response string to deserialize.

        Returns:
            dict: A dictionary representing the data contained in the
                JSON serialized string.


        """
        if dynamic_response is not None or not str(dynamic_response):
            return ApiHelper.json_deserialize(dynamic_response)

    @staticmethod
    @validate_call
    def date_deserialize(json: Optional[str]) -> Union[datetime.date, List[datetime.date]]:
        """JSON Deserialization of a given string.

        Args:
            json (str): The JSON serialized string to deserialize.

        Returns:
            dict: A dictionary representing the data contained in the
                JSON serialized string.

        """
        deserialized_response = ApiHelper.json_deserialize(json)
        if isinstance(deserialized_response, list):
            return [dateutil.parser.parse(element).date() for element in deserialized_response]

        return dateutil.parser.parse(deserialized_response).date()

    @staticmethod
    @validate_call
    def datetime_deserialize(
            value: Optional[Union[str, float]], datetime_format: Optional[DateTimeFormat]
    ) -> Union[None, CustomDate, Dict[str, CustomDate], List[CustomDate]]:
        """JSON Deserialization of a given string.

        Args:
            value: the response to deserialize
           datetime_format: The date time format to deserialize into

        Returns:
            dict: A dictionary representing the data contained in the
                JSON serialized string.

        """
        if value is None:
            return None

        if isinstance(value, str):
            deserialized_response = ApiHelper.json_deserialize(value)
        else:
            deserialized_response = value

        if DateTimeFormat.HTTP_DATE_TIME == datetime_format:
            if isinstance(deserialized_response, list):
                return [element.datetime for element in
                        ApiHelper.json_deserialize(str(value), ApiHelper.HttpDateTime.from_value)]
            else:
                return ApiHelper.HttpDateTime.from_value(value).datetime
        elif DateTimeFormat.UNIX_DATE_TIME == datetime_format:
            if isinstance(deserialized_response, list):
                return [element.datetime for element in
                        ApiHelper.json_deserialize(str(value), ApiHelper.UnixDateTime.from_value)]
            else:
                return ApiHelper.UnixDateTime.from_value(value).datetime
        elif DateTimeFormat.RFC3339_DATE_TIME == datetime_format:
            if isinstance(deserialized_response, list):
                return [element.datetime for element in
                        ApiHelper.json_deserialize(str(value), ApiHelper.RFC3339DateTime.from_value)]
            else:
                return ApiHelper.RFC3339DateTime.from_value(value).datetime

        return deserialized_response

    @staticmethod
    @validate_call(config=dict(arbitrary_types_allowed=True))
    def deserialize_union_type(
            union_type: UnionType, value: Any, should_deserialize: bool=True
    ) -> Any:
        if should_deserialize and isinstance(value, str):
            value = ApiHelper.json_deserialize(value, as_dict=True)

        union_type_result = union_type.validate(value)

        return union_type_result.deserialize(value)

    @staticmethod
    @validate_call
    def get_content_type(value: Any) -> Optional[str]:
        """Get content type header for oneof.

        Args:
            value: The value passed by the user.

        Returns:
            dict: A dictionary representing the data contained in the
                JSON serialized string.

        """
        if value is None:
            return None
        primitive = (int, str, bool, float)

        if type(value) in primitive:
            return 'text/plain; charset=utf-8'

        else:
            return 'application/json; charset=utf-8'

    @staticmethod
    @validate_call
    def get_schema_path(path: str, file_name: str) -> str:
        """Return the Schema's path

        Returns:
            string : returns Correct schema path

        """
        pascal_name = file_name.replace("_", " ").title().replace(" ", "")
        path = path.replace('\\models', '\\schemas').replace('/models', '/schemas') \
            .replace(".py", ".json").replace(file_name, pascal_name)
        return path

    @staticmethod
    @validate_call
    def serialize_array(
            key: str, array: List[Any], formatting: SerializationFormats=SerializationFormats.INDEXED,
            is_query: bool=False
    ) -> List[Tuple[str, Any]]:
        """Converts an array parameter to a list of key value tuples.

        Args:
            key (str): The name of the parameter.
            array (list): The value of the parameter.
            formatting (str): The type of key formatting expected.
            is_query (bool): Decides if the parameters are for query or form.

        Returns:
            list: A list with key value tuples for the array elements.

        """
        tuples: List[Tuple[str, Any]] = []

        serializable_types = (str, int, float, bool, datetime.date, ApiHelper.CustomDate)

        if isinstance(array[0], serializable_types):
            if formatting == SerializationFormats.UN_INDEXED:
                tuples += [("{0}[]".format(key), element) for element in array]
            elif formatting == SerializationFormats.INDEXED:
                tuples += [("{0}[{1}]".format(key, index), element) for index, element in enumerate(array)]
            elif formatting == SerializationFormats.PLAIN:
                tuples += [(key, element) for element in array]
            elif is_query:
                if formatting == SerializationFormats.CSV:
                    tuples += [(key, ",".join(str(x) for x in array))]

                elif formatting == SerializationFormats.PSV:
                    tuples += [(key, "|".join(str(x) for x in array))]

                elif formatting == SerializationFormats.TSV:
                    tuples += [(key, "\t".join(str(x) for x in array))]
                else:
                    raise ValueError("Invalid format provided.")
            else:
                raise ValueError("Invalid format provided.")
        else:
            tuples += [("{0}[{1}]".format(key, index), element) for index, element in enumerate(array)]

        return tuples

    @staticmethod
    @validate_call
    def append_url_with_template_parameters(url: Optional[str], parameters: Optional[Dict[str, Dict[str, Any]]]) -> str:
        """Replaces template parameters in the given url.

        Args:
            url (str): The query url string to replace the template parameters.
            parameters (dict): The parameters to replace in the url.

        Returns:
            str: URL with replaced parameters.

        """
        # Parameter validation
        if url is None:
            raise ValueError("URL is None.")

        if parameters is None:
            return url

        # Iterate and replace parameters
        for key in parameters:
            value = parameters[key]['value']
            encode = parameters[key]['encode']
            replace_value = ''

            # Load parameter value
            if value is None:
                replace_value = ''
            elif isinstance(value, list):
                replace_value = "/".join((quote(str(x), safe='') if encode else str(x)) for x in value)
            else:
                replace_value = quote(str(value), safe='') if encode else str(value)

            url = url.replace('{{{0}}}'.format(key), str(replace_value))

        return url

    @staticmethod
    @validate_call
    def append_url_with_query_parameters(
            url: Optional[str], parameters: Optional[Dict[str, Any]],
            array_serialization: SerializationFormats=SerializationFormats.INDEXED
    ) -> str:
        """Adds query parameters to a URL.

        Args:
            url (str): The URL string.
            parameters (dict): The query parameters to add to the URL.
            array_serialization (str): The format of array parameter serialization.

        Returns:
            str: URL with added query parameters.

        """
        # Parameter validation
        if url is None:
            raise ValueError("URL is None.")

        if parameters is None:
            return url

        query_parameters = ApiHelper.process_complex_types_parameters(parameters, array_serialization)
        for value in query_parameters:
            key = value[0]
            val = value[1]
            seperator = '&' if '?' in url else '?'
            if value is not None:
                url += "{0}{1}={2}".format(seperator, key, quote(str(val), safe=''))

        return url

    @staticmethod
    @validate_call
    def get_url_without_query(url: str) -> str:
        """
        Extracts the protocol, domain, and path from a URL excluding the query parameters.

        Args:
            url: The URL string.

        Returns:
            A string containing the protocol, domain, and path of the URL without the query string.

        Raises:
            ValueError: If the URL is invalid.
        """
        try:
            parsed_url = urlsplit(url)
            if not parsed_url.netloc:  # Check if URL has scheme and netloc (valid URL)
                raise ValueError("Invalid URL format")
            return f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"
        except ValueError as e:
            raise ValueError(f"Error parsing URL: {e}") from e

    @staticmethod
    @validate_call
    def process_complex_types_parameters(
            query_parameters: Dict[str, Any], array_serialization: SerializationFormats
    ) -> List[Tuple[str, Any]]:
        processed_params = []
        for key, value in query_parameters.items():
            processed_params.extend(
                ApiHelper.form_encode(value, key, array_serialization=array_serialization, is_query=True))
        return processed_params

    @staticmethod
    @validate_call
    def clean_url(url: str) -> str:
        """Validates and processes the given query Url to clean empty slashes.

        Args:
            url (str): The given query Url to process.

        Returns:
            str: Clean Url as string.

        """
        # Ensure that the urls are absolute
        regex = "^https?://[^/]+"
        match = re.match(regex, url)
        if match is None:
            raise ValueError('Invalid Url format.')

        protocol = match.group(0)
        index = url.find('?')
        query_url = url[len(protocol): index if index != -1 else None]
        query_url = re.sub("//+", "/", query_url)
        parameters = url[index:] if index != -1 else ""

        return protocol + query_url + parameters

    @staticmethod
    @validate_call
    def form_encode_parameters(
            form_parameters: Dict[str, Any], array_serialization: SerializationFormats=SerializationFormats.INDEXED
    ) -> List[Tuple[str, Any]]:
        """Form encodes a dictionary of form parameters

        Args:
            form_parameters (dictionary): The given dictionary which has
            atleast one model to form encode.
            array_serialization (str): The format of array parameter serialization.

        Returns:
            dict: A dictionary of form encoded properties of the model.

        """
        encoded = []

        for key, value in form_parameters.items():
            encoded += ApiHelper.form_encode(value, key, array_serialization)

        return encoded

    @staticmethod
    @validate_call
    def form_encode(
            obj: Any, instance_name: str,
            array_serialization: SerializationFormats=SerializationFormats.INDEXED, is_query: bool=False
    ) -> List[Tuple[str, Any]]:
        """Encodes a model in a form-encoded manner such as person[Name]

        Args:
            obj (object): The given Object to form encode.
            instance_name (string): The base name to appear before each entry
                for this object.
            array_serialization (string): The format of array parameter serialization.
            is_query (bool): Decides if the parameters are for query or form.

        Returns:
            dict: A dictionary of form encoded properties of the model.

        """
        retval = []
        # If we received an object, resolve its field names.
        if ApiHelper.is_custom_type(obj):
            obj = ApiHelper.json_serialize(obj, should_encode=False)

        if obj is None:
            return []
        elif isinstance(obj, list):
            for element in ApiHelper.serialize_array(instance_name, obj, array_serialization, is_query):
                retval += ApiHelper.form_encode(element[1], element[0], array_serialization, is_query)
        elif isinstance(obj, dict):
            for item in obj:
                retval += ApiHelper.form_encode(obj[item], instance_name + "[" + item + "]", array_serialization,
                                                is_query)
        else:
            if isinstance(obj, bool):
                obj = str(obj).lower()
            retval.append((instance_name, obj))

        return retval

    @staticmethod
    @validate_call
    def apply_datetime_converter(
            value: Any,
            datetime_converter_obj: Callable[[Any], Any]) -> Any:
        if isinstance(value, list):
            return [ApiHelper.apply_datetime_converter(item, datetime_converter_obj) for item in value]

        if isinstance(value, dict):
            return {k: ApiHelper.apply_datetime_converter(v, datetime_converter_obj) for k, v in value.items()}

        if isinstance(value, datetime.datetime):
            return ApiHelper.when_defined(datetime_converter_obj, value)

        return value

    @staticmethod
    @validate_call
    def when_defined(func: Callable[[datetime.datetime], Any], value: datetime.datetime) -> Any:
        return func(value) if value else None

    @staticmethod
    @validate_call
    def is_file_wrapper_instance(param: Any) -> bool:
        return isinstance(param, FileWrapper)

    @staticmethod
    def is_valid_type(
            value: Any, type_callable: Callable[[Any], bool], is_value_nullable: bool=False, is_model_dict: bool=False,
            is_inner_model_dict: bool=False
    ) -> bool:
        if value is None and is_value_nullable:
            return True

        if isinstance(value, list):
            return all(ApiHelper.is_valid_type(item, type_callable, is_value_nullable, is_model_dict,
                                               is_inner_model_dict) for item in value)
        elif isinstance(value, dict) and (not is_model_dict or is_inner_model_dict):
            return all(ApiHelper.is_valid_type(item, type_callable, is_value_nullable, is_model_dict)
                       for item in value.values())

        return value is not None and type_callable(value)

    @staticmethod
    @validate_call
    def resolve_template_placeholders_using_json_pointer(
            placeholders: Set[str], value: Optional[Dict[str, Any]], template: str
    ) -> str:
        """Updates all placeholders in the given message template with provided value.

        Args:
            placeholders: The placeholders that need to be searched and replaced in the given template value.
            value: The dictionary containing the actual values to replace with.
            template: The template string containing placeholders.

        Returns:
            string: The resolved template value.
        """
        for placeholder in placeholders:
            extracted_value: Optional[str] = ''

            if '#' in placeholder:
                # pick the 2nd chunk then remove the last character (i.e. `}`) of the string value
                node_pointer = placeholder.rsplit('#')[1].rstrip('}')
                try:
                    extracted_value = resolve_pointer(value, node_pointer) if node_pointer else ''
                    extracted_value = ApiHelper.json_serialize(extracted_value) \
                        if type(extracted_value) in [list, dict] else str(extracted_value)
                except JsonPointerException:
                    pass
            elif value is not None:
                extracted_value = ApiHelper.json_serialize(value)
            template = template.replace(placeholder, extracted_value or '')

        return template

    @staticmethod
    @validate_call
    def resolve_template_placeholders(placeholders: Set[str], values: Union[str, Dict[str, Any]], template: str) -> str:
        """Updates all placeholders in the given message template with provided value.

                Args:
                    placeholders: The placeholders that need to be searched and replaced in the given template value.
                    values: The dictionary|string value which refers to the actual values to replace with.
                    template: The template string containing placeholders.

                Returns:
                    string: The resolved template value.
                """
        for placeholder in placeholders:
            if isinstance(values, abc.Mapping):
                # pick the last chunk then strip the last character (i.e. `}`) of the string value
                key = placeholder.rsplit('.', maxsplit=1)[-1].rstrip('}') if '.' in placeholder \
                    else placeholder.lstrip('{').rstrip('}')
                value_to_replace = str(values.get(key)) if values.get(key) else ''
                template = template.replace(placeholder, value_to_replace)
            else:
                values = str(values) if values is not None else ''
                template = template.replace(placeholder, values)

        return template

    @staticmethod
    @validate_call
    def to_lower_case(list_of_string: Optional[List[str]]) -> Optional[List[str]]:
        """Converts all strings in a list to lowercase.

        Args:
            list_of_string (list): A list of strings to convert to lowercase.

        Returns:
            list: A new list containing the lowercase versions of the input strings.
                Returns None if the input list is None.

        Raises:
            TypeError: If the input is not a list.
        """
        if list_of_string is None:
            return None

        return list(map(lambda x: x.lower(), list_of_string))

    @staticmethod
    def sanitize_model(**kwargs: Any) -> Dict[str, Any]:
        _sanitized_dump: Dict[str, Any] = {}
        _nullable_fields: Set[str] = kwargs.get('nullable_fields', set())
        _optional_fields: Set[str] = kwargs.get('optional_fields', set())
        _model_dump: Dict[str, Any] = kwargs.get('model_dump', {})
        _model_fields: Dict[str, FieldInfo] = kwargs.get('model_fields', {})
        _model_fields_set: Set[str] = kwargs.get('model_fields_set', set())

        for _name, _field_info in _model_fields.items():
            _value = _model_dump.pop(_name, None)
            _alias = _field_info.serialization_alias or _name

            if _name not in _nullable_fields and _name not in _optional_fields:
                # Always include required properties
                _sanitized_dump[_alias] = _value

            elif _name in _nullable_fields and _name in _optional_fields:
                # Include optional_nullable properties if explicitly set or not None
                if _value is not None or _name in _model_fields_set:
                    _sanitized_dump[_alias] = _value

            elif _name in _optional_fields:
                # Exclude optional properties if None
                if _value is not None:
                    _sanitized_dump[_alias] = _value

            elif _name in _nullable_fields:
                # Always include nullable properties, even if None
                _sanitized_dump[_alias] = _value

        return _sanitized_dump

    @staticmethod
    def check_conflicts_with_additional_properties(
            model_cls: BaseModel, properties: Dict[str, Any], additional_props_field: str
    ) -> None:
        """Raise ValueError if properties contain names conflicting with model fields."""
        defined_fields = {
            alias or name
            for name, field_info in model_cls.model_fields.items()
            if name != additional_props_field  # Dynamically exclude additional properties field
            for alias in (field_info.serialization_alias, name)
        }

        conflicting_keys = defined_fields.intersection(properties)
        if conflicting_keys:
            raise ValueError(
                f"Invalid additional properties: {conflicting_keys}. "
                "These names conflict with existing model properties."
            )
