# -*- coding: utf-8 -*-

"""
testerxml

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""

import xml.etree.ElementTree as ET
import datetime
import dateutil.parser
from typing import Any, List, Dict, Optional, Type, Callable, Union

from pydantic import validate_call

from apimatic_core.utilities.api_helper import ApiHelper


class XmlHelper:
    """This class hold utility methods for xml serialization and
        deserialization.
    """

    @staticmethod
    @validate_call
    def serialize_to_xml(value: Any, root_element_name: str) -> Optional[str]:
        """Serializes a given value to an XML document.

        Args:
            value (Any): The value to serialize.
            root_element_name (str): The name of the document's root element.

        Returns:
            str: Serialized XML string.
        """
        if value is None:
            return None

        root = ET.Element(root_element_name)

        if value is not None:
            XmlHelper.add_to_element(root, value)

        return ET.tostring(root).decode()

    @staticmethod
    @validate_call
    def serialize_list_to_xml(value: Optional[List[Any]], root_element_name: str, array_item_name: str) -> Optional[str]:
        """Serializes a given list of values to an XML document.

        Args:
            value (List[Any]): The list of values to serialize.
            root_element_name (str): The name of the document's root element.
            array_item_name (str): The element name to use for each item in 'values'.

        Returns:
            str: Serialized XML string.
        """
        if value is None:
            return None

        root = ET.Element(root_element_name)

        XmlHelper.add_list_as_subelement(root, value, array_item_name)

        return ET.tostring(root).decode()

    @staticmethod
    @validate_call
    def serialize_dict_to_xml(value: Optional[Dict[str, Any][], root_element_name: str) -> str:
        """Serializes a given dictionary of values to an XML document.

        Args:
            value (Dict[str, Any]): The dictionary to serialize.
            root_element_name (str): The name of the document's root element.

        Returns:
            str: Serialized XML string.
        """
        if value is None:
            return None

        root = ET.Element(root_element_name)

        XmlHelper.add_dict_as_subelement(root, value)

        return ET.tostring(root).decode()

    @staticmethod
    @validate_call(config=dict(arbitrary_types_allowed=True))
    def add_to_element(element: ET.Element, value: Any) -> None:
        """Converts the given value to XML and adds it to an existing ET.Element.

        Args:
            element (ET.Element): The XML tag to add the 'value' to.
            value (Any): The value to add to the element.
        """
        if value is None:
            return

        if isinstance(value, bool):
            element.text = str(value).lower()
        elif isinstance(value, (int, float, str, datetime.date, ApiHelper.CustomDate)):
            element.text = str(value)
        else:
            value.to_xml_sub_element(element)

    @staticmethod
    @validate_call(config=dict(arbitrary_types_allowed=True))
    def add_as_attribute(root: ET.Element, value: Any, name: str) -> None:
        """Sets an attribute on an ET.Element instance if the value isn't None.

        Args:
            root (ET.Element): The parent of this XML attribute.
            value (Any): The value to set to the attribute.
            name (str): The name of the attribute being set.
        """
        if value is not None:
            root.set(name, str(value).lower() if isinstance(value, bool) else str(value))

    @staticmethod
    @validate_call(config=dict(arbitrary_types_allowed=True))
    def add_as_subelement(root: ET.Element, value: Any, name: str) -> None:
        """Converts the given value to an ET.Element if it is not None and adds it to an existing ET.Element.

        Args:
            root (ET.Element): The parent of this XML element.
            value (Any): The value to add to the element.
            name (str): The name of the element being added.
        """
        if value is not None:
            tag = ET.SubElement(root, name)
            XmlHelper.add_to_element(tag, value)

    @staticmethod
    @validate_call(config=dict(arbitrary_types_allowed=True))
    def add_list_as_subelement(root: ET.Element, items: Optional[List[Any]], item_name: str,
                               wrapping_element_name: Optional[str] = None) -> None:
        """Converts the given list to an ET.Element if it is not None and adds it to an existing ET.Element.

        Args:
            root (ET.Element): The parent of this XML element.
            items (List[Any]): The list of values to add to the element.
            item_name (str): The element name to use for each item in 'items'.
            wrapping_element_name (Optional[str]): The element name to use for the wrapping element, if needed.
        """
        if items is not None:
            parent = ET.SubElement(root, wrapping_element_name) if wrapping_element_name else root
            for item in items:
                sub_elem = ET.SubElement(parent, item_name)
                XmlHelper.add_to_element(sub_elem, item)

    @staticmethod
    @validate_call(config=dict(arbitrary_types_allowed=True))
    def add_dict_as_subelement(root: ET.Element, items: Dict[str, Any], dictionary_name: Optional[str] = None) -> None:
        """Converts the given dictionary to an ET.Element if it is not None and adds it to an existing ET.Element.

        Args:
            root (ET.Element): The parent of this XML element.
            items (Dict[str, Any]): The dictionary of values to add to the element.
            dictionary_name (Optional[str]): The element name to use for the encapsulating element.
        """
        if items is not None:
            parent = ET.SubElement(root, dictionary_name) if dictionary_name else root
            for key, value in items.items():
                if isinstance(value, list):
                    XmlHelper.add_list_as_subelement(parent, value, key)
                else:
                    XmlHelper.add_as_subelement(parent, value, key)

    @staticmethod
    @validate_call
    def deserialize_xml(xml: Optional[str], clazz: Type[Any]) -> Optional[Any]:
        """Deserializes an XML document to a Python object of the type given by 'clazz'.

        Args:
            xml (Optional[str]): An XML document to deserialize.
            clazz (Type[Any]): The class that the deserialized object should belong to.

        Returns:
            Optional[Any]: An instance of the specified class, or None if input is empty.
        """
        if not xml:
            return None

        root = ET.fromstring(xml)
        return XmlHelper.value_from_xml_element(root, clazz)

    @staticmethod
    @validate_call
    def deserialize_xml_to_list(xml: Optional[str], item_name: str, clazz: Type[Any]) -> Optional[List[Any]]:
        """Deserializes an XML document to a list of Python objects, each of the type given by 'clazz'.

        Args:
            xml (Optional[str]): An XML document to deserialize.
            item_name (str): The name of the elements that need to be extracted into a list.
            clazz (Type[Any]): The class that the deserialized objects should belong to.

        Returns:
            Optional[List[Any]]: A list of instances of the specified class, or None if input is empty.
        """
        if not xml:
            return None

        root = ET.fromstring(xml)
        return XmlHelper.list_from_xml_element(root, item_name, clazz)

    @staticmethod
    @validate_call
    def deserialize_xml_to_dict(xml: Optional[str], clazz: Type[Any]) -> Optional[Dict[str, Any]]:
        """Deserializes an XML document to a dictionary of Python objects, each of the type given by 'clazz'.

        Args:
            xml (Optional[str]): An XML document to deserialize.
            clazz (Type[Any]): The class that the dictionary values should belong to.

        Returns:
            Optional[Dict[str, Any]]: A dictionary with deserialized objects, or None if input is empty.
        """
        if not xml:
            return None

        root = ET.fromstring(xml)
        return XmlHelper.dict_from_xml_element(root, clazz)

    @staticmethod
    @validate_call(config=dict(arbitrary_types_allowed=True))
    def value_from_xml_attribute(attribute: Optional[Union[ET.Element, str]], clazz: Type[Any]) -> Optional[Any]:
        """Extracts the value from an attribute and converts it to the type
            given by 'clazz'.

        Args:
            attribute (str): The XML attribute to extract the value from.
            clazz (Type[Any]): The class that the deserialized object should
                belong to.
        """
        if attribute is None:
            return None

        conversion_function = XmlHelper.converter(clazz)

        return conversion_function(attribute)\
            if conversion_function is not None and isinstance(attribute, str) else None

    @staticmethod
    @validate_call(config=dict(arbitrary_types_allowed=True))
    def value_from_xml_element(element: Optional[ET.Element], clazz: Type[Any]) -> Optional[Any]:
        """Extracts the value from an element and converts it to the type given by 'clazz'.

        Args:
            element (ET.Element): The XML element to extract the value from.
            clazz (Type[Any]): The class that the deserialized object should belong to.

        Returns:
            Optional[Any]: An instance of the specified class, or None if the element is None.
        """
        if element is None:
            return None

        # These classes can be cast directly.
        if clazz in [int, float, str, bool, datetime.date] or \
                issubclass(clazz, ApiHelper.CustomDate):
            conversion_function = XmlHelper.converter(clazz)
            return conversion_function(element.text)\
                if conversion_function is not None and element.text is not None else None

        conversion_function = clazz.from_element if hasattr(clazz, 'from_element') else None

        return conversion_function(element) if conversion_function is not None and element is not None else None



    @staticmethod
    @validate_call(config=dict(arbitrary_types_allowed=True))
    def list_from_xml_element(root: Optional[ET.Element], item_name: str, clazz: Type[Any],
                              wrapping_element_name: Optional[str] = None) -> Optional[List[Any]]:
        """Deserializes an XML document to a list of Python objects, each of the type given by 'clazz'.

        Args:
            root (ET.Element): The root XML element.
            item_name (str): The name of the elements that need to be extracted into a list.
            clazz (Type[Any]): The class that the deserialized objects should belong to.
            wrapping_element_name (Optional[str]): The name of the wrapping element for the XML element array.

        Returns:
            Optional[List[Any]]: A list of deserialized objects, or None if no matching elements are found.
        """
        if root is None:
            return None

        elements = XmlHelper.get_elements(root, wrapping_element_name, item_name)

        if elements is None:
            return None

        return [XmlHelper.value_from_xml_element(element, clazz) for element in elements]

    @staticmethod
    @validate_call(config=dict(arbitrary_types_allowed=True))
    def dict_from_xml_element(element: Optional[ET.Element], clazz: Type[Any]) -> Optional[Dict[str, Any]]:
        """Extracts the values from an element and converts them to a dictionary with values of type 'clazz'.

        Args:
            element (ET.Element): The XML element to convert.
            clazz (Type[Any]): The class that the dictionary values should belong to.

        Returns:
            Optional[Dict[str, Any]]: A dictionary of deserialized values, or None if the element is None.
        """
        if element is None:
            return None

        entries = list(element)
        conversion_function = XmlHelper.converter(clazz)
        return {
            entry.tag: conversion_function(entry.text) if entry.text is not None else None
            for entry in entries if conversion_function
        }

    @staticmethod
    @validate_call
    def converter(clazz: Type[Any]) -> Optional[Callable[[str], Any]]:
        """Provides the function to use for converting a string to the type given by 'clazz'.

        Args:
            clazz (Type[Any]): The class to find the conversion function for.

        Returns:
            Callable[[str], Any]: A conversion function, or None if not applicable.
        """
        if clazz in [int, float, str]:
            return lambda value: clazz(value)
        elif clazz is bool:
            return lambda value: value.lower() == 'true'
        elif clazz is datetime.date:
            return lambda value: dateutil.parser.parse(value).date()
            # DateTime classes have their own method to convert from string.
        elif issubclass(clazz, ApiHelper.CustomDate):
            return clazz.from_value

        return None

    @staticmethod
    @validate_call(config=dict(arbitrary_types_allowed=True))
    def value_from_one_of_xml_elements(
            root: Optional[ET.Element], mapping_data: Optional[Dict[str, Any]]
    ) -> Optional[Any]:
        """Extracts the value from an element and converts it to the type given
            by 'clazz'.

        Args:
            root (ET.Element): The root XML element.
            mapping_data (dict): A dictionary mapping possible element names
            for a given field to corresponding types.
        """
        if not mapping_data or root is None:
            return None

        for element_name, tup in mapping_data.items():
            clazz = tup[0]
            is_array = tup[1]
            wrapping_element_name = tup[2]
            if is_array:
                elements = XmlHelper.get_elements(root, wrapping_element_name, element_name)
                if elements is not None and len(elements) > 0:
                    return XmlHelper.list_from_xml_element(
                        root, element_name, clazz, wrapping_element_name)
            else:
                element = root.find(element_name)
                if element is not None:
                    return XmlHelper.value_from_xml_element(element, clazz)
        return None

    @staticmethod
    @validate_call(config=dict(arbitrary_types_allowed=True))
    def list_from_multiple_one_of_xml_element(root: ET.Element, mapping_data: Dict[str, Any]) -> Optional[List[Any]]:
        """Deserializes an xml document to a list of python objects
           where all types of oneof schemas are allowed (when the outer
           model is an array)

        Args:
            root (ET.Element): An xml document to deserialize.
            mapping_data (dict): A dictionary mapping possible element names
            for a given field to corresponding types.

        """
        arr = []
        for elem in root.iter():
            if elem.tag in mapping_data:
                arr.append(XmlHelper.value_from_xml_element(
                    elem, mapping_data[elem.tag][0]))
        if len(arr) > 0:
            return arr
        else:
            return None

    @staticmethod
    @validate_call(config=dict(arbitrary_types_allowed=True))
    def get_elements(root: Optional[ET.Element], wrapping_element_name: Optional[str], item_name: str) -> Optional[List[ET.Element]]:
        """Retrieves a list of XML elements based on the specified wrapping element and item name.

        Args:
            root (ET.Element): The root XML element.
            wrapping_element_name (Optional[str]): The name of the wrapping element.
            item_name (str): The name of the desired elements.

        Returns:
            Optional[List[ET.Element]]: A list of matching elements, or None if not found.
        """
        if root is None:
            return None

        if wrapping_element_name is None:
            return root.findall(item_name)
        wrapping_element = root.find(wrapping_element_name)
        if wrapping_element is None:
            return None
        return wrapping_element.findall(item_name)
